# 事件驱动（Event-Driven）

事件驱动是一种架构与编程范式：系统通过“事件”来传递状态变化，事件生产者与消费者解耦，组件之间通过发布与订阅进行协作。

## 1. 基本概念

- 事件（Event）：描述发生了什么的事实，例如“订单已支付”。
- 事件生产者（Producer）：产生并发布事件的组件。
- 事件消费者（Consumer）：订阅并处理事件的组件。
- 事件总线 / 消息系统：承载事件传递的基础设施（如 Kafka、RabbitMQ、EventBridge）。

## 2. 典型流程

1. 业务发生变化（写入数据库或状态更新）。
2. 生产者发布事件。
3. 消息系统分发事件到订阅者。
4. 消费者异步处理事件并完成后续动作。

## 3. 适用场景

- 需要解耦的系统（微服务、模块化系统）。
- 处理链条较长、需要异步化的业务。
- 高并发、高吞吐的日志与监控系统。
- 需要弹性扩展的业务流程。

## 4. 优势

- 解耦：生产者无需知道消费者存在。
- 异步：提升响应速度，降低同步调用链。
- 可扩展：消费者可独立扩容。
- 事件留存：便于审计、回溯和重放。

## 5. 挑战与风险

- 一致性：跨服务事务难以保证强一致。
- 事件丢失或重复：需要幂等处理与可靠投递。
- 顺序性：部分业务需要事件有序处理。
- 可观测性：排查链路问题更复杂。

## 6. 关键设计点

### 6.1 事件建模

- 事件名称清晰、表达事实。
- 事件载荷包含必要上下文（如业务 id、时间戳）。
- 建议加入版本字段便于演进。

### 6.2 可靠投递

- 使用消息持久化与确认机制（ack）。
- 结合本地消息表或 Outbox 模式，避免发布失败。

### 6.3 幂等与去重

- 消费端基于业务唯一键或事件 id 做幂等。
- 避免重复事件引发副作用。

### 6.4 顺序性

- 按业务 key 做分区（如订单 id）。
- 保证同一 key 的事件按序消费。

### 6.5 失败处理

- 重试策略：指数退避、最大重试次数。
- 死信队列（DLQ）处理不可恢复错误。

## 7. 与消息驱动的区别

事件驱动强调“事实发生”，消息驱动强调“指令传达”。

- 事件：描述已发生的事实，通常不可变。
- 命令：希望执行的动作，可能失败或被拒绝。

## 8. 常见模式

- 发布 / 订阅（Pub/Sub）。
- 事件溯源（Event Sourcing）。
- CQRS（读写分离）。
- Saga（分布式事务补偿）。

## 9. 简化心智模型

事件驱动 = 状态变化 -> 事件 -> 消息系统 -> 异步处理。
