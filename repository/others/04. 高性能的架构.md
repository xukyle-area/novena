# 一、“高性能” 的定义

第一句话不要直接讲技术。

> 高性能服务的核心目标是：
> 在可控成本下，实现高吞吐、低延迟、稳定性和可扩展性的平衡。

然后拆成 4 个维度：

1. 吞吐量（QPS / TPS）
2. 延迟（P99 / P999）
3. 稳定性（不抖、不雪崩）
4. 可扩展性（水平扩展能力）

这一步体现你是系统思维，而不是堆技术。

---

# 二、设计思路：自底向上分层

我一般用五层模型来回答：

1. 计算层
2. IO层
3. 数据层
4. 架构层
5. 保护层

---

# 三、第一层：计算层优化

核心目标：减少上下文切换 + 提高CPU利用率

### 1. 使用异步非阻塞模型

* Reactor / Netty
* epoll
* NIO

避免：

* 同步阻塞线程模型
* 每请求一个线程

---

### 2. 减少锁竞争

* 无锁结构（Disruptor）
* CAS
* 分段锁
* 读写锁
* 尽量避免 synchronized 粗锁

在撮合、行情系统中，单线程模型反而更快（避免锁）

---

### 3. 减少对象创建

* 对象池
* 复用 buffer
* 避免频繁 GC

交易系统里：

* 使用 long 代替 BigDecimal
* 价格使用整数表示

---

# 四、第二层：IO优化

### 1. 网络优化

* 长连接
* 批量发送
* TCP参数优化
* 零拷贝（sendfile / mmap）

---

### 2. 序列化优化

* Protobuf
* FlatBuffers
* 避免 JSON

在行情推送场景，JSON 是性能杀手。

---

# 五、第三层：数据层优化

这是很多人答不好的一层。

### 1. 缓存优先

* Redis
* 本地缓存（Caffeine）
* 多级缓存

### 2. 数据分片

* 按 userId 分片
* 按 symbol 分片
* 按时间分表

交易所典型：

* BTCUSDT 一个撮合引擎
* ETHUSDT 一个撮合引擎

避免全局锁。

---

### 3. 读写分离

* 主写从读
* CQRS

---

# 六、第四层：架构层设计

### 1. 无状态服务

* 方便水平扩展
* Kubernetes 横向扩容

---

### 2. 水平扩展优于垂直扩展

不要靠升级机器解决问题。

---

### 3. 事件驱动架构

* Kafka
* 内部消息队列

把同步链路改成异步。

---

# 七、第五层：保护机制

高性能系统必须抗压。

### 1. 限流

* Token Bucket
* Redis Zset 限流

---

### 2. 熔断

* 防止下游拖死系统

---

### 3. 降级

* 非核心功能关闭
* 风控可延迟

---

### 4. 隔离

* 线程池隔离
* 进程隔离
* 账户隔离

---

# 八、交易所级别的进阶优化（加分项）

如果是你去面试，可以加这段：

### 1. 单线程撮合模型

避免锁竞争，保证顺序性。

### 2. 内存订单簿

不要依赖数据库。

### 3. 批量落库

异步持久化。

### 4. 预分配内存

避免运行时扩容。

---

# 九、面试标准回答模板

你可以直接背这个版本：

---

> 设计高性能服务，我一般从五个层面考虑：
> 计算模型、IO优化、数据结构与缓存、架构设计、以及系统保护机制。
>
> 在计算层面，我会采用异步非阻塞模型，减少线程上下文切换，并尽量减少锁竞争，例如采用单线程模型或无锁结构。
>
> 在IO层面，会优化网络连接和序列化方式，避免JSON等低效格式。
>
> 在数据层面，会优先使用缓存和分片设计，避免全局锁和热点数据问题。
>
> 架构上保持无状态服务，支持水平扩展，并通过消息队列实现解耦。
>
> 最后通过限流、熔断和隔离机制保证系统在高压下依然稳定。

---

# 十、真正的高手会补一句

> 高性能不是堆技术，而是消除瓶颈。
> 所以我会通过压测和profiling先找到系统瓶颈，再做针对性优化。

这句话非常加分。

---

如果你愿意，我可以：

* 给你一份「交易所高性能系统设计面试答题模板」
* 或者给你一份「电商系统高性能设计版本」
* 或者给你一个「从 0 到 100w QPS 的演进路径」

你想往哪种场景准备？
