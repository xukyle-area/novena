# 零拷贝（Zero Copy）

**零拷贝（Zero Copy）就是：**

> 在数据传输过程中，尽量减少 CPU 参与的数据拷贝次数。

目的只有一个：

✔ 减少内存拷贝
✔ 减少 CPU 开销
✔ 提高吞吐
✔ 降低延迟

------

# 一、先理解：传统 IO 做了多少次拷贝？

我们看一个典型场景：

客户端请求下载一个文件。

```text
磁盘 → 内核缓冲区 → 用户缓冲区 → Socket缓冲区 → 网卡
```

在传统 read + write 模型下，会发生：

### 1️⃣ 第一次拷贝

磁盘 → 内核缓冲区（DMA）

### 2️⃣ 第二次拷贝

内核缓冲区 → 用户空间（CPU copy）

### 3️⃣ 第三次拷贝

用户空间 → Socket缓冲区（CPU copy）

### 4️⃣ 第四次

Socket → 网卡（DMA）

其中：

- 有 2 次 CPU 内存拷贝
- 有 2 次 用户态 / 内核态切换

这很浪费。

<img src="../imgs/zero_copy.png" alt="img" style="zoom:50%;" />

------

# 二、零拷贝的优化后

Linux 提供 `sendfile()`：

```text
磁盘 → 内核缓冲区 → Socket缓冲区 → 网卡
```

少了什么？

不再拷贝到用户空间
不需要用户态参与

现在：

- 少了一次 CPU copy
- 少了一次上下文切换

这就是零拷贝。

<img src="../imgs/senfile.png" alt="img" style="zoom:50%;" />

------

# 三、更高级的零拷贝

现代内核会进一步优化：

网卡可以直接从 page cache 读数据发送。

```text
磁盘 → page cache → 网卡
```

CPU 几乎不参与数据搬运。

<img src="../imgs/senfile_new.png" alt="img" style="zoom:50%;" />

------

# 四、Java 中的零拷贝

在 Java 里常见方式：

### 1️⃣ FileChannel.transferTo()

本质调用 sendfile()

```java
fileChannel.transferTo(...)
```

### 2️⃣ Netty 的零拷贝

- CompositeByteBuf
- DirectBuffer
- sendfile

------

# 五、零拷贝解决什么问题？

高并发文件传输
高吞吐网关
行情广播
日志系统

举例：

交易所推行情，如果用传统 IO，每秒几万次内存 copy，会压爆 CPU。

零拷贝可以让 CPU 专心做业务逻辑。