## 一、第一代：`SETNX` ——「能用，但很危险」

### 1. 最原始做法

```bash
SETNX lock:key 1
```

* 成功：拿到锁
* 失败：说明别人持有锁

### 2. 立刻暴露的问题

**问题 1：死锁**

* 客户端拿到锁
* 还没 `DEL` 就宕机
* 锁永远不释放

**补救方案（早期常见）**

```bash
SETNX lock:key timestamp
```

* 发现锁过期就“抢”
* **但这一步不是原子操作**

### 3. 进化到原子操作

Redis 2.6.12 之后：

```bash
SET lock:key value NX EX 10
```

一次完成：

* `NX`：不存在才设置
* `EX`：自动过期

这是 **分布式锁的最小可用形态**。

---

### 4. 仍然致命的问题

**问题 2：误删别人的锁**

```text
线程 A：拿到锁（10s）
线程 A：GC 停顿 12s
锁过期
线程 B：拿到锁
线程 A：恢复执行，DEL lock:key ❌
```

### 5. 引入「锁的唯一标识」

```bash
SET lock:key uuid NX EX 10
```

释放时：

```lua
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
end
```

✔ 解决误删
❌ **但仍不是严格意义的“安全分布式锁”**

---

## 二、第二代：Redlock ——「理论上的分布式锁」

> Redis 作者 antirez 提出的算法
> 目标：**解决单 Redis 实例的不可靠性**

---

### 1. Redlock 的核心思想

* 使用 **多个相互独立的 Redis 节点**（通常 5 个）
* 在 **大多数节点** 上加锁成功，才算成功

### 2. 加锁流程（简化版）

1. 生成唯一 value
2. 在 N 个 Redis 上执行：

   ```bash
   SET key value NX PX ttl
   ```
3. 若在 `ttl` 内：

   * 成功 >= `N/2 + 1`
   * 且耗时 < `ttl`
4. 加锁成功

---

### 3. Redlock 试图解决什么？

| 问题          | 是否解决   |
| ----------- | ------ |
| 单点 Redis 宕机 | ✔      |
| 主从切换锁丢失     | ✔（理论上） |
| 锁过期自动释放     | ✔      |
| 误删锁         | ✔      |

---

### 4. 为什么 Redlock 争议巨大？

**Martin Kleppmann（分布式系统大佬）**公开反对：

#### 核心争议点

1. **依赖时钟假设**

   * 假设各节点时间流逝“差不多”
2. **网络分区下仍可能双持锁**
3. **复杂度高，收益有限**
4. **业务是否真的需要“严格分布式锁”？**

一句话总结：

> Redlock 在“理论正确性”和“工程可控性”之间，站得并不稳。

---

### 5. 现实中的结论

* **Redis 官方：Redlock 是一个可选方案**
* **业界共识**：

  * 不建议自己实现
  * 更不建议当“强一致锁”用

---

## 三、第三代：Redisson ——「工程化分布式锁」

Redisson 的定位非常明确：

> **不是提出新算法，而是把“能用 + 可控 + 易用”做到极致**

---

### 1. Redisson 锁的核心设计

#### （1）Lua 原子操作

* 加锁 / 续期 / 解锁全部 Lua
* 天然原子性

#### （2）锁唯一标识（线程级）

```text
{clientId}:{threadId}
```

---

### 2. Watch Dog（看门狗）机制 ⭐

这是 Redisson 的杀手锏。

* 默认锁过期时间：30s
* 只要线程还活着：

  * 每 10s 自动续期
* 线程挂了：

  * 不再续期
  * 锁最终过期

✔ 解决 **业务执行时间不可预估**
✔ 避免 ttl 设置过短 / 过长

---

### 3. 可重入锁

```java
RLock lock = redisson.getLock("order:lock");
lock.lock();
lock.lock(); // 可重入
```

Redis 内部结构：

```text
hash:
  field = clientId:threadId
  value = 重入次数
```

---

### 4. 解锁安全性

* 只允许 **持有锁的线程** 解锁
* Lua 校验 ownership
* 不存在误删

---

### 5. Redisson 是不是 Redlock？

关键点：

| 模式      | 默认       |
| ------- | -------- |
| 单 Redis | ✔        |
| 主从      | ✔        |
| Redlock | ❌（需显式开启） |

👉 **Redisson 默认不使用 Redlock**

原因很现实：

* 复杂
* 性价比低
* 大多数业务不需要

---

## 四、三代方案横向对比

| 方案              | 适合场景  | 核心问题           |
| --------------- | ----- | -------------- |
| SETNX           | 简单互斥  | 死锁 / 误删        |
| SET NX EX + Lua | 普通业务  | 单点问题           |
| Redlock         | 理论分布式 | 争议大            |
| Redisson        | 工程实践  | Redis 仍是 CP 不足 |
