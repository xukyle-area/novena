# G1 (Garbage-First) Garbage Collector – Detailed Overview

## 1. What is G1

G1 (Garbage-First) is a **server-style, low-latency, region-based garbage collector** introduced in JDK 7 and made the **default collector starting from JDK 9**. It was designed to replace CMS by providing:

* Predictable pause times
* Concurrent marking
* Compaction without long Full GC pauses
* Better behavior on large heaps (multi-GB to 100+ GB)

Unlike CMS, G1 manages the **entire heap** rather than focusing only on the old generation.

---

## 2. Design Goals

G1 was designed with the following explicit goals:

* Predictable pause times (soft real-time)
* High heap utilization
* Minimal fragmentation
* Reasonable throughput without extreme tuning

Key idea:

> "Collect the most garbage first while respecting a pause-time goal."

---

## 3. Heap Layout: Regions

G1 divides the heap into many **fixed-size regions** (typically 1–32 MB):

* Regions are equal-sized
* Region role is **dynamic**
* No fixed young/old generation layout

### 3.1 Region Types

* Eden regions
* Survivor regions
* Old regions
* Humongous regions (for large objects)
* Free regions

An object may move between region types across GC cycles.

---

## 4. Remembered Sets (RSet)

Because G1 does **partial heap collection**, it must track cross-region references.

Each region maintains a **Remembered Set (RSet)**:

* Records references **into** the region
* Enables region-local GC without scanning the entire heap
* Maintained using write barriers

Cost trade-off:

* Higher memory usage
* Additional CPU overhead

---

## 5. G1 Collection Types

G1 does not distinguish Minor / Major GC in the traditional sense.

### 5.1 Young GC (STW)

* Collects Eden + Survivor regions
* Fully parallel, STW
* Objects are evacuated (copied)
* Very predictable pause times

---

### 5.2 Mixed GC (STW)

* Collects:

  * All young regions
  * A **selected set of old regions**
* Old regions chosen based on:

  * Garbage ratio
  * Estimated collection cost

This is the core "Garbage-First" idea.

---

### 5.3 Full GC (Fallback)

* Single-threaded (older JDKs) or parallel (newer JDKs)
* Triggered by allocation failure or metadata exhaustion
* Very expensive
* Should be rare in a healthy G1 configuration

---

## 6. G1 Concurrent Marking Cycle

The concurrent marking cycle identifies live objects across the heap.

### 6.1 Initial Mark (STW)

* Marks GC roots
* Piggybacks on a Young GC
* Very short pause

---

### 6.2 Concurrent Mark

* Traverses object graph concurrently
* Uses Snapshot-At-The-Beginning (SATB)
* Tracks reference changes via write barriers

---

### 6.3 Remark (STW)

* Completes marking
* Processes SATB buffers
* Short but noticeable pause

---

### 6.4 Cleanup (STW + Concurrent)

* Calculates live data per region
* Identifies regions eligible for Mixed GC
* Reclaims completely empty regions

---

## 7. Evacuation and Compaction

G1 is a **compacting collector by design**:

* Live objects are copied (evacuated) to new regions
* Source regions become free
* Eliminates fragmentation

This happens incrementally during Young and Mixed GCs.

---

## 8. Humongous Objects

Objects larger than **50% of a region size** are classified as humongous:

* Allocated directly into old-generation regions
* Occupy one or more contiguous regions
* Reclaimed only during marking cleanup or Full GC

Humongous allocations can:

* Increase pause times
* Cause premature Full GC

---

## 9. Pause-Time Model

G1 uses a **pause-time prediction model**:

* User specifies a target:

  ```text
  -XX:MaxGCPauseMillis=200
  ```
* G1 estimates:

  * Cost per region
  * Object copy time
* Selects regions that fit within the target

This is a **soft goal**, not a strict SLA.

---

## 10. Key JVM Options for G1

```text
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:InitiatingHeapOccupancyPercent=45
-XX:G1HeapRegionSize=8m
-XX:+ParallelRefProcEnabled
```

Explanation:

* `InitiatingHeapOccupancyPercent`: start concurrent marking
* `G1HeapRegionSize`: region size (usually auto-selected)

---

## 11. G1 vs CMS

| Aspect               | CMS        | G1           |
| -------------------- | ---------- | ------------ |
| Heap layout          | Continuous | Region-based |
| Compaction           | No         | Yes          |
| Pause predictability | Low        | High         |
| Fragmentation        | High       | Low          |
| Tuning difficulty    | High       | Medium       |
| Status               | Deprecated | Default      |

---

## 12. Common G1 Failure Modes

### 12.1 Evacuation Failure

* Not enough free regions to copy live objects
* Triggers Full GC

Causes:

* Heap too small
* Excessive humongous objects

---

### 12.2 To-Space Exhausted

* Target regions fill up during evacuation
* Results in long pauses or Full GC

---

## 13. When G1 Is a Good Choice

G1 is suitable when:

* Heap size ≥ 4 GB
* Latency-sensitive services
* Mixed read/write workloads
* Desire for minimal GC tuning

---

## 14. Limitations of G1

* Higher memory overhead (RSets)
* Less optimal for very small heaps
* Humongous object behavior still suboptimal

---

## 15. Summary

G1 is a balanced, production-grade garbage collector that combines concurrent marking, incremental compaction, and pause-time predictability. It successfully addresses the major weaknesses of CMS and serves as the foundation for modern low-latency GC design in HotSpot.
