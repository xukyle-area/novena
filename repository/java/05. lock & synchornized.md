# synchronized vs java.util.concurrent.locks.Lock

## 1. Overview

In Java, thread synchronization can be achieved mainly through two mechanisms:

* `synchronized` (built-in language keyword)
* `java.util.concurrent.locks.Lock` (explicit locking API, e.g. `ReentrantLock`)

Both ensure **mutual exclusion** and **memory visibility**, but they differ significantly in design philosophy, flexibility, and usage scenarios.

---

## 2. synchronized: Language-Level Monitor Lock

`synchronized` is a **JVM-level construct** based on the **monitor** concept.

### 2.1 What synchronized Locks

* Instance method → locks the object (`this`)
* Static method → locks the `Class` object
* Synchronized block → locks the specified object

```java
synchronized (lockObject) {
    // critical section
}
```

---

### 2.2 Monitor Internals

Each object has an associated **monitor**, which includes:

* Owner thread
* Entry list (blocked threads)
* Wait set (threads calling `wait()`)

JVM ensures:

* Mutual exclusion
* Automatic lock release

---

### 2.3 JVM Optimizations

Modern JVMs heavily optimize `synchronized`:

* Biased locking
* Lightweight locking (CAS-based)
* Lock coarsening
* Lock elimination

As a result, uncontended `synchronized` is **very cheap**.

---

## 3. Lock Interface (java.util.concurrent.locks)

`Lock` is an **explicit locking abstraction** introduced in Java 5.

Most commonly used implementation:

* `ReentrantLock`

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    // critical section
} finally {
    lock.unlock();
}
```

---

## 4. ReentrantLock Internals

`ReentrantLock` is built on:

* AQS (AbstractQueuedSynchronizer)
* CAS + FIFO wait queue

Key components:

* State (lock count)
* Owner thread
* CLH-based wait queue

---

## 5. Feature Comparison

| Feature             | synchronized | Lock / ReentrantLock      |
| ------------------- | ------------ | ------------------------- |
| Lock acquisition    | Implicit     | Explicit (`lock()`)       |
| Lock release        | Automatic    | Manual (`unlock()`)       |
| Reentrancy          | Yes          | Yes                       |
| Fair lock           | No           | Optional                  |
| Try lock            | No           | Yes (`tryLock`)           |
| Interruptible lock  | No           | Yes (`lockInterruptibly`) |
| Multiple conditions | No           | Yes (`Condition`)         |
| JVM optimization    | Yes          | Limited                   |

---

## 6. Memory Semantics (Happens-Before)

Both mechanisms provide the same memory guarantees:

* Unlock **happens-before** subsequent lock on the same monitor/lock
* Changes inside critical section are visible to other threads

From a JMM perspective:

> `synchronized` ≈ `Lock` (correctly used)

---

## 7. Condition Variables

### 7.1 synchronized + wait/notify

* Single implicit condition per monitor
* `wait()` releases the lock
* `notify()` / `notifyAll()` wakes threads

Limitations:

* Hard to manage multiple conditions
* Error-prone

---

### 7.2 Lock + Condition

```java
Condition notEmpty = lock.newCondition();
Condition notFull = lock.newCondition();
```

Advantages:

* Multiple condition queues
* Clear semantics
* More precise wake-ups

---

## 8. Fairness

### 8.1 synchronized

* Non-fair
* Thread scheduling controlled by JVM and OS

---

### 8.2 ReentrantLock

* Supports fairness policy:

```java
new ReentrantLock(true); // fair
```

Trade-off:

* Fair lock → lower throughput

---

## 9. Performance Characteristics

### 9.1 Low Contention

* `synchronized` often equals or outperforms `ReentrantLock`
* Thanks to JVM intrinsics and optimizations

### 9.2 High Contention

* `ReentrantLock` scales better
* Features like tryLock and interruptibility help avoid deadlocks

---

## 10. Failure Modes

### 10.1 synchronized

* Deadlock possible
* No timeout
* Cannot be interrupted while waiting

---

### 10.2 Lock

* Forgetting `unlock()` causes deadlock
* More verbose, easier to misuse

---

## 11. Typical Use Cases

### Prefer synchronized when:

* Lock scope is simple
* No need for timeout or fairness
* Code clarity is important

### Prefer Lock when:

* Need try-lock or timed lock
* Need interruptible locking
* Multiple condition queues required
* High contention scenarios

---

## 12. Interview-Level Summary

* `synchronized` is JVM-managed, simple, safe, and highly optimized
* `Lock` is library-managed, flexible, and feature-rich
* Performance difference is usually **not the deciding factor**
* Choose based on **capability requirements**, not habit

---

## 13. One-Sentence Takeaway

> Use `synchronized` by default; switch to `Lock` only when you explicitly need its advanced features.