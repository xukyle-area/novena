# Concurrent Mark Sweep (CMS) Garbage Collector

## 1. What is CMS

Concurrent Mark Sweep (CMS) is a low-pause garbage collector in the HotSpot JVM, primarily designed for applications that are sensitive to latency and cannot tolerate long stop-the-world (STW) pauses. CMS focuses on reducing pause times by performing most of its work concurrently with application threads.

CMS is a **generational, old-generation collector**:

* Young generation: typically uses **ParNew** (a parallel STW collector)
* Old generation: uses **CMS** (mostly concurrent)

> CMS was officially deprecated starting from JDK 9 and removed in later versions, replaced mainly by G1 and ZGC.

---

## 2. Design Goals

The core design goals of CMS are:

* Minimize stop-the-world pause time
* Maintain high application responsiveness
* Accept higher CPU usage in exchange for lower latency

CMS explicitly **does not aim** to:

* Maximize throughput
* Eliminate fragmentation

---

## 3. CMS Heap Structure

CMS operates within the traditional HotSpot heap layout:

* Young Generation

  * Eden
  * Survivor (S0, S1)
* Old Generation (CMS-managed)
* Metaspace (or PermGen in very old JDKs)

Objects are promoted from the young generation to the old generation, where CMS handles reclamation.

---

## 4. CMS Collection Phases

A full CMS cycle consists of several phases, some STW and some concurrent.

### 4.1 Initial Mark (STW)

* Marks objects directly reachable from GC Roots
* Very short pause
* Only marks the initial object graph entry points

**GC Roots include:**

* Thread stacks
* Static variables
* JNI references

---

### 4.2 Concurrent Mark

* Traces the object graph starting from the initial marked objects
* Runs concurrently with application threads
* Application threads continue allocating and mutating objects

**Key challenge:** object graph may change while marking is in progress.

---

### 4.3 Concurrent Preclean

* Attempts to reduce work in the next STW phase
* Tracks object reference changes (via write barriers)
* Cleans up references that changed during concurrent marking

This phase is opportunistic and may repeat.

---

### 4.4 Remark (STW)

* Finalizes marking
* Processes remaining mutations missed during concurrent mark
* Uses Snapshot-At-The-Beginning (SATB)-like techniques
* Pause time is longer than Initial Mark, but much shorter than a full STW GC

---

### 4.5 Concurrent Sweep

* Reclaims memory from unreachable objects
* Adds freed memory to free lists
* Runs concurrently with application threads

No compaction occurs in this phase.

---

### 4.6 Concurrent Reset

* Resets CMS internal data structures
* Prepares for the next CMS cycle
* Runs concurrently

---

## 5. Snapshot-At-The-Beginning (SATB) Concept

CMS uses a **logical snapshot** of the heap at the beginning of the marking phase:

* Objects reachable at the start of marking are considered live
* Objects allocated during concurrent marking are treated as live by default

This avoids the need to chase newly created objects during marking, simplifying correctness at the cost of floating garbage.

---

## 6. Floating Garbage

**Floating garbage** refers to objects that:

* Become unreachable during the CMS cycle
* Are not reclaimed until the next CMS cycle

Consequences:

* Higher memory usage
* Requires more headroom compared to compacting collectors

---

## 7. Fragmentation Issues

CMS does **not compact** the old generation by default.

Effects:

* Memory fragmentation over time
* Allocation failures despite sufficient total free memory

### 7.1 Promotion Failure

Occurs when:

* A large object cannot find a contiguous free block
* Triggers a fallback Full GC (serial, compacting, STW)

---

## 8. Concurrent Mode Failure

A **Concurrent Mode Failure** happens when:

* CMS cannot finish marking/sweeping before the old generation fills up
* JVM falls back to a Full GC

Common causes:

* Insufficient heap size
* Allocation rate too high
* CMS started too late

---

## 9. Key JVM Options for CMS

```text
-XX:+UseConcMarkSweepGC
-XX:+UseParNewGC
-XX:CMSInitiatingOccupancyFraction=70
-XX:+UseCMSInitiatingOccupancyOnly
-XX:+CMSClassUnloadingEnabled
-XX:+CMSParallelRemarkEnabled
```

Explanation:

* `CMSInitiatingOccupancyFraction`: heap usage threshold to start CMS
* `UseCMSInitiatingOccupancyOnly`: disables adaptive triggering
* `CMSParallelRemarkEnabled`: parallelizes remark phase

---

## 10. CMS vs Other Collectors

| Collector   | Pause Time | Throughput  | Compaction | Status           |
| ----------- | ---------- | ----------- | ---------- | ---------------- |
| CMS         | Low        | Medium      | No         | Deprecated       |
| G1          | Low        | Medium–High | Yes        | Default (JDK 9+) |
| ZGC         | Very Low   | Medium      | Yes        | Modern           |
| Parallel GC | High       | Very High   | Yes        | Legacy           |

---

## 11. When CMS Was a Good Choice

CMS was suitable when:

* JVM version ≤ JDK 8
* Latency-sensitive services (e.g., trading, gateways)
* Heap size was moderate
* Engineers could tolerate tuning complexity

---

## 12. Why CMS Was Deprecated

Key reasons:

* Complexity and tuning difficulty
* Fragmentation problems
* Better alternatives (G1, ZGC, Shenandoah)
* High maintenance cost in HotSpot

---

## 13. Summary

CMS is a historically important low-latency garbage collector that pioneered concurrent marking and sweeping in HotSpot. While effective in reducing pause times, it suffers from fragmentation, floating garbage, and fallback Full GCs. Modern JVMs favor region-based and fully concurrent compacting collectors that address these limitations more robustly.
