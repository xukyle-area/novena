# Java ConcurrentHashMap – Detailed Implementation and Design

## 1. What is ConcurrentHashMap

`ConcurrentHashMap` is a **thread-safe, high-concurrency** implementation of the `Map` interface in Java. It is designed to support **concurrent reads and writes** with minimal contention, avoiding the global locking approach used by `Hashtable` or `Collections.synchronizedMap`.

Key characteristics:

* Thread-safe without synchronizing the entire map
* High throughput under concurrent access
* Does **not allow null keys or null values**
* Provides weakly consistent iterators

---

## 2. Design Evolution: JDK 7 vs JDK 8

### 2.1 JDK 7 Design: Segment-Based Locking

In JDK 7, `ConcurrentHashMap` uses **segmented locking**:

* Map is divided into multiple `Segment`s
* Each `Segment` is a small hash table protected by a `ReentrantLock`
* Concurrency level ≈ number of segments

```text
ConcurrentHashMap
 ├── Segment[ ]
 │    └── HashEntry[ ]
```

Limitations:

* Fixed concurrency level
* Higher memory overhead
* Less flexible scalability

---

### 2.2 JDK 8 Design: Node + CAS + Synchronized

JDK 8 completely redesigned `ConcurrentHashMap`:

* **No Segment**
* Uses:

  * CAS (Compare-And-Swap)
  * Fine-grained `synchronized` on buckets
* Data structure similar to `HashMap`

```text
Node<K,V>[] table
```

This design scales better with CPU cores.

---

## 3. Core Data Structure (JDK 8+)

Each bucket may contain:

* A linked list of `Node`
* A red-black tree (`TreeBin`)

Each `Node` contains:

* key (final)
* value (volatile)
* hash
* next (volatile)

Volatile fields guarantee **visibility** across threads.

---

## 4. Put Operation (JDK 8)

### 4.1 High-Level Workflow

1. Compute hash
2. Locate bucket index
3. If bucket is empty:

   * Insert using CAS
4. If bucket is not empty:

   * Lock the bucket head (`synchronized`)
   * Traverse list or tree
   * Update or insert
5. If bucket too large → treeify

---

### 4.2 Why CAS + synchronized

* CAS: fast path for uncontended inserts
* `synchronized`: simpler and more efficient than `ReentrantLock` for short critical sections

---

## 5. Get Operation

* Lock-free
* Reads volatile fields
* Traverses bucket safely

Time complexity:

* Average: O(1)
* Worst-case: O(log n)

---

## 6. Resize Mechanism (Cooperative Rehashing)

Resize is **incremental and concurrent**:

* Triggered when size exceeds threshold
* Multiple threads help resize
* Uses `ForwardingNode` to redirect access

Key idea:

> Resize work is shared across threads instead of blocking them.

---

## 7. Treeification

Conditions:

* Bucket size ≥ 8
* Table size ≥ 64

Same thresholds as `HashMap`, but operations are thread-safe.

---

## 8. Counting Elements (Size)

Uses **striped counters**:

* `baseCount` + `CounterCell[]`
* Reduces contention compared to a single atomic counter

`size()`:

* May be slightly inaccurate under concurrency
* Eventually consistent

---

## 9. Memory Visibility and Happens-Before

Thread safety relies on:

* `volatile` fields
* CAS operations
* `synchronized` blocks

Guarantees:

* Writes before unlock are visible after lock
* CAS establishes happens-before relationship

---

## 10. Iterators and Weak Consistency

Iterators are:

* Weakly consistent
* Do not throw `ConcurrentModificationException`
* Reflect state during or after iteration begins

Trade-off:

* Correctness over strict consistency

---

## 11. Why Null Keys Are Forbidden

Reasons:

* Avoid ambiguity in `get()` return value
* Simplify concurrent logic
* Eliminate special-case handling

---

## 12. Performance Characteristics

| Aspect           | ConcurrentHashMap | HashMap | Hashtable |
| ---------------- | ----------------- | ------- | --------- |
| Thread-safe      | Yes               | No      | Yes       |
| Lock granularity | Bucket-level      | N/A     | Global    |
| Read lock        | None              | N/A     | Global    |
| Throughput       | High              | Highest | Low       |

---

## 13. Common Interview Topics

* Why JDK 8 removed Segment
* CAS vs synchronized trade-offs
* Resize implementation
* Size accuracy
* Difference from HashMap

---

## 14. Typical Use Cases

* Caches
* Concurrent counters
* Shared configuration maps
* High-QPS services

---

## 15. Summary

`ConcurrentHashMap` represents a mature concurrency design combining lock-free reads, fine-grained locking, and cooperative resizing. The JDK 8 redesign significantly simplified the architecture while improving scalability and maintainability, making it the de facto choice for concurrent key–value storage in Java.
