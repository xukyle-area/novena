# 使用 nonce 和 时间戳 参加加密密文的计算是什么原因？

---

## 一、结论

> **nonce + 时间戳参与签名的核心目的只有一个：防重放攻击（Replay Attack）**
> 顺带解决：请求唯一性、时效性校验、接口幂等、安全审计。

**不是为了“更难算”**，而是为了**“同一请求不能被重复利用”**。

---

## 二、如果没有 nonce / 时间戳，会发生什么？

假设一个典型签名：

```text
sign = HMAC(secret, method + path + body)
```

### 攻击者只需要做一件事

* 抓一次合法请求
* 原样重复发送

```http
POST /withdraw
Body: { "amount": 1000 }
Headers: sign=abc123
```

👉 **服务器无法区分**

* 是你刚刚发的
* 还是 10 秒 / 10 分钟 / 明天重放的

这在：

* 提现
* 下单
* 转账
* 改配置

场景下都是**致命漏洞**。

---

## 三、时间戳：解决「请求时效性」

### 常见设计

```http
timestamp = 1700000000
```

服务器校验：

```text
abs(server_time - timestamp) <= 30s
```

### 它解决的问题

* **旧请求直接失效**
* 即使签名被截获
* 超过时间窗口也不能用

### 但时间戳有一个致命缺陷

> **时间窗口内，依然可以被重放**

30 秒内抓到包 → 重放 100 次 → 全是合法的。

---

## 四、nonce：解决「时间窗口内的重放」

### nonce 是什么？

> **一次性随机值（Number used once）**

```http
nonce = 9f8a2c71...
```

### 服务端做什么？

* 记录已使用的 nonce（通常配合 appKey / user）
* 再次出现 → **直接拒绝**

```text
(appKey, nonce) 已存在 → replay attack
```

### nonce 单独用行不行？

理论上行，但工程上不行：

* nonce 需要存
* 不清理会爆炸
* 清理需要 TTL

👉 所以 **nonce 一定和时间戳一起用**

---

## 五、nonce + 时间戳 + 签名 = 完整防重放方案

典型签名串：

```text
method + path + body + timestamp + nonce
```

服务端校验顺序通常是：

1. 校验 timestamp 是否过期
2. 校验 nonce 是否已使用
3. 校验签名是否合法
4. 执行业务逻辑

这样可以：

| 风险           | 是否防住 |
| -------------- | -------- |
| 抓包后重复发送 | 防住     |
| 延迟重放       | 防住     |
| 中间人复制请求 | 防住     |
| 请求顺序错乱   | 可检测   |

---

## 六、为什么 nonce 不能用自增 id？

很多人踩过这个坑。

```text
nonce = 123456
```

问题：

* 并发下顺序不可控
* 容易被预测
* 攻击者可以构造未来 nonce

👉 **nonce 必须是不可预测的随机值**

---

## 七、为什么还要把它们“参与签名”？

关键点来了。

### 如果不参与签名

```http
timestamp = 1700000000
nonce = abc
sign = HMAC(secret, body)
```

攻击者可以：

* 原样拿你的 sign
* 改 timestamp / nonce
* 重放成功

👉 **必须一起参与签名，否则等于没用**

---

## 八、工程上的真实好处（你在交易所一定见过）

结合你之前做交易所 / 行情 / 风控系统，我直接点名用途：

### 1️⃣ 防止下单 / 提现被重复执行

尤其是：

* 网络重试
* SDK 自动重发
* 代理层重放

### 2️⃣ 实现天然幂等

`nonce` 就是天然 request_id

```text
同 nonce 的请求，只能成功一次
```

### 3️⃣ 方便审计和追责

* 每次请求唯一
* 可以精准定位异常行为

### 4️⃣ 限流 & 风控辅助

* 单 appKey nonce 频率异常
* 时间戳异常偏移

---

## 九、为什么几乎所有开放平台都这么干？

因为这是：

> **在 HTTP 之上，实现“近似一次性请求”的最小成本方案**

不需要：

* TLS 终止态信任
* 连接态 session
* 双向证书

非常适合：

* 公网
* 多语言 SDK
* 高并发
* 无状态服务