> **同一毫秒多个请求是完全正常的，ZSET 本身不怕，怕的是 member 设计错了。**

---

## 一、ZSET 真正唯一的是谁？

**Redis ZSET 的唯一键不是 score，而是 member。**

```text
ZADD key score member
```

* score：可以重复（✔）
* member：**必须唯一**（❗）

👉 所以 **同一毫秒多个请求完全没问题**，只要 `member` 不一样。

---

## 二、错误示例（很多线上事故就出在这）

### ❌ 错误做法

```redis
ZADD rate_limit:key 1700000000123 1700000000123
```

或：

```redis
ZADD rate_limit:key 1700000000123 "1700000000123"
```

**问题：**

* 同一毫秒的请求 → member 一样
* ZADD 变成 **更新 score**
* ZCARD 不变
* 👉 **限流形同虚设**

---

## 三、正确的 member 设计方式

### ✅ 方案 1：时间戳 + 随机数（最常用）

```text
member = timestamp + ":" + random
```

例：

```redis
ZADD key 1700000000123 "1700000000123:834721"
```

**优点**

* 简单
* 快
* 几乎不冲突

---

### ✅ 方案 2：UUID（最稳妥）

```redis
ZADD key 1700000000123 "550e8400-e29b-41d4-a716-446655440000"
```

**优点**

* 理论上零冲突
* 实现最简单

**缺点**

* member 稍大，占点内存

---

### ✅ 方案 3：自增序列（高级但少用）

```redis
INCR rate_limit:seq:{key}
ZADD key timestamp seq
```

**优点**

* 绝对不冲突
* member 极小

**缺点**

* 多一次 Redis 访问
* Lua 里实现才优雅

---

## 四、在 Lua 脚本里怎么优雅解决？

### 推荐做法（生产级）

**在 Lua 里直接用随机数拼 member：**

```lua
local now = tonumber(ARGV[1])
local rand = math.random(1000000)
local member = now .. ":" .. rand

redis.call('ZADD', key, now, member)
```

或者 **客户端生成 UUID，Lua 只负责逻辑**（更常见）。

---

## 五、并发极高时，还有隐藏问题吗？

### 1️⃣ 同一毫秒大量请求，会不会 ZSET 排序乱？

不会。

* ZSET 按 `(score, member)` 排序
* score 相同 → 按 member 字典序
* **ZREMRANGEBYSCORE 只看 score，不受影响**

---

### 2️⃣ 会不会影响限流精度？

不会。

你关心的是：

```text
窗口内请求“数量”
```

不是顺序。

---

### 3️⃣ 毫秒不够怎么办？

极端场景（比如撮合、风控）：

* 用 **微秒时间戳**
* 或 score = `timestamp * 1000 + seq`

但说实话：

> **99% 的 Web / API 限流，毫秒完全够用**