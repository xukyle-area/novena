## 一、用 ZSET 做限流，本质是什么？

**一句话版：**

> 用 ZSET 按时间戳排序，记录每一次请求；
> 通过清理窗口外数据 + 统计窗口内数量，判断是否超限。

这是一个 **Sliding Window Log（滑动窗口日志）** 的实现。

---

## 二、Redis 里的数据结构设计

### 1️⃣ Key 设计

通常按 **限流维度** 来分 key：

```text
rate_limit:{biz}:{uid}
rate_limit:{biz}:{ip}
rate_limit:{biz}:{api}
```

例子：

```text
rate_limit:login:uid_123
rate_limit:order:create:ip_1.2.3.4
```

---

### 2️⃣ ZSET 的结构

```text
ZSET key
  score   -> 请求时间戳（毫秒）
  member  -> 请求唯一标识
```

示例：

```text
ZADD rate_limit:login:uid_123 1700000000123 req-uuid-1
ZADD rate_limit:login:uid_123 1700000000456 req-uuid-2
```

* **score**：时间戳（ms）
* **member**：唯一值（uuid / timestamp+rand），防止覆盖

---

## 三、完整限流算法（核心流程）

假设规则是：

> **1 分钟内最多 100 次请求**

### Step 1：计算时间窗口

```text
now = 当前时间戳
window_start = now - 60_000
```

---

### Step 2：清理窗口外的请求

```redis
ZREMRANGEBYSCORE key 0 window_start
```

👉 删除 1 分钟之前的请求

---

### Step 3：统计窗口内请求数

```redis
ZCARD key
```

---

### Step 4：判断是否超限

* `count < limit` → **允许**
* `count >= limit` → **拒绝**

---

### Step 5：记录本次请求（允许时）

```redis
ZADD key now req_uuid
```

---

### Step 6：设置过期时间（很重要）

```redis
EXPIRE key 120
```

> 避免冷 key 永久存在
> TTL 一般设置为 **窗口的 2~3 倍**

---

## 四、原子性：为什么一定要用 Lua？

如果你直接用多条 Redis 命令：

```text
ZREMRANGEBYSCORE
ZCARD
ZADD
```

**在并发下会有竞态条件，限流会不准**。

### 正确做法：Lua 脚本（生产必备）

伪代码：

```lua
local key = KEYS[1]
local now = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local limit = tonumber(ARGV[3])
local member = ARGV[4]

redis.call('ZREMRANGEBYSCORE', key, 0, now - window)
local count = redis.call('ZCARD', key)

if count >= limit then
    return 0
end

redis.call('ZADD', key, now, member)
redis.call('EXPIRE', key, math.ceil(window / 1000) * 2)

return 1
```

---

## 五、这种限流的优点和缺点

### ✅ 优点

* **精确滑动窗口**
* 没有“突刺”（不像固定窗口）
* 规则直观，容易调试
* 非常适合：

  * 登录
  * 下单
  * API 网关
  * 交易接口（你这个领域用得非常多）

---

### ❌ 缺点

* **内存占用较高**

  * QPS 高时，ZSET 会存很多 member
* 每次请求至少：

  * 1 次 ZREMRANGEBYSCORE
  * 1 次 ZCARD
  * 1 次 ZADD

所以：

> ❗ 不适合「百万 QPS 全量限流」

---

## 六、和其他限流方案的对比（工程视角）

| 方案            | 精度     | 内存    | 复杂度 | 场景      |
| ------------- | ------ | ----- | --- | ------- |
| 固定窗口（INCR）    | 低      | 低     | 简单  | 简单接口    |
| 漏桶            | 中      | 低     | 中   | 平滑流量    |
| 令牌桶           | 高      | 低     | 中   | 网关限流    |
| **ZSET 滑动窗口** | **最高** | **高** | 中   | 风控 / 交易 |

你在交易所、风控系统里看到的：

* **用户下单频率**
* **API 调用限额**
* **防刷、防爆破**

很多都是 ZSET 或其变种。

---

## 七、实战经验

1️⃣ **member 一定要唯一**

```text
timestamp + random 或 uuid
```

否则 ZADD 会覆盖

---

2️⃣ **毫秒级时间戳**

```text
System.currentTimeMillis()
```

秒级精度在高并发下不够

---

3️⃣ **key 粒度要控制**

```text
不要一个 key 限所有人
```

会把 ZSET 打爆

---

4️⃣ **QPS 极高时的优化**

* 多级限流（本地 + Redis）
* 或改用 **token bucket**

---

## 八、总结

> **Redis ZSET 限流 = 用时间戳做 score 的滑动窗口日志**
> 精确、直观、可靠，但用在“关键接口”，而不是“所有接口”。